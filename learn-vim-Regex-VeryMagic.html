<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" type="text/css" href="learn-vi.css" />
	<title>VIM学习笔记 正则表达式(Regex-VeryMagic)</title>
</head>
<body>
	<h1>VIM学习笔记 ()</h1>

	<h2 class="article"><a id=""></a></h2>
	<p></p>
	<a href="#" title=""></a>


	<h2 class="article"><a id="regex-very-magic"></a>Very magic</h2>
	<p>Very magic mode is activated using <code class="insert">\v</code>. since it makes the regex mostly perl-compatible. Unfortunately, you can’t make it the default.</p>
	<p></p>
	<p style="text-indent:2em"><code class="inset"></code></p>
  <li>E.g. search for a url starting with <code class="highlighter-rouge">www</code> and ending with <code class="highlighter-rouge">.com</code>: <code class="highlighter-rouge">\vwww\..*\.com</code></li>
	<p>定义以下键盘映射，始终使用very magic模式：</p>
	<p style="text-indent:2em"><code class="inset">noremap / /\v</code></p>

	<h2 class="article"><a id=""></a>Very nomagic</h2>
	<p>Very nomagic modes are set with \V. Their effect is turning almost all special regex symbols into ordinary ones unless they start with a backslash.</p>
	<p>例如以下命令，将查找字符串&ldquo;Fun.test(*args)&rdquo; 。也就是说，其中的&ldquo;*&rdquo;和&ldquo;.&rdquo;都被视为普通字符。如果您需要精确的完整匹配，并且查找字符串中包含特殊字符时，那么Very nomagic模式将会很有用。</p>
	<p style="text-indent:2em"><code class="inset">/\VFun.test(*args)</code></p>
          <p>which allows you to use parenthesis, brackets, the alternative separator (i.e. ‘|’), pluses, etc. with their special meaning but without the need to escape those characters.</p>
	<p style="text-indent:2em"><code class="inset">:help /\v</code></p>

	<pre class="block"></pre>

	<p><a href="https://yyq123.github.io/learn-vim/images/.png" title=""><img src="https://yyq123.github.io/learn-vim/images/.png" alt="" width="500" height="" /></a></p>

	<p style="color:gray; font-size:0.6em"><a href="http://yyq123.github.io/learn-vim/images/.png" title=""><img src="http://yyq123.github.io/learn-vim/images/.png" alt="" /></a></br>Source: medium.com/free-code-camp</p>

	<pre class="block">
	</pre>

	<ul>
		<li><p class="item"><br /></p></li>
		<li><p class="item"><a href="#" title=""></a><br /></p></li>
	</ul>

	<span style="font-weight:bold; color:#4169E1; margin-left:0.2em">&#65311;</span>

	<p>假设在以下文本中，希望搜索单引号包围的内容：</p>
	<p style="color:#fff; background-color:#1D1F21; width:21em; padding:10px">
	you have mocking some 'bird of the year'.<br />
	you have mocking some 'the year's bird'.</p>

	<p>在默认打开magic选项的情况下，可以使用以下命令：</p>
	<p style="text-indent:2em"><code class="inset">/'\('\w\|[^']\)\+'</code></p>
	<p style="color:#fff; background-color:#1D1F21; width:21em; padding:10px">
        you have mocking some <span style="background-color:#FDAD00">'bird of the year'</span>.<br />
	you have mocking some <span style="background-color:#FDAD00">'the year's bird'</span>.</p>
	<p>如果使用VeryMagic模式，命令则可以简化为：</p>
	<p style="text-indent:2em"><code class="inset">/\v'('\w|[^'])+'</code></p>

	<p>假设在以下文本中，希望仅保留字符内容：</p>
	<p style="color:#fff; background-color:#1D1F21; width:21em; padding:10px">
	12345aaa678<br />
	12345bbb678<br />
	12345ccc678</p>
	<p>使用以下替换命令：</p>
	<p style="text-indent:2em"><code class="inset">:%s/\d\{5\}\(\D\+\)\d\{3\}/\1/</code></p>
	<p style="color:#fff; background-color:#1D1F21; width:21em; padding:10px">
	aaa<br />
	bbb<br />
	ccc</p>
	<p>如果使用VeryMagic模式，命令则可以简化为：</p>
	<p style="text-indent:2em"><code class="inset">:%s/\v\d{5}(\D+)\d{3}/\1/</code></p>

	<p>避免重复输入大量的转义符（\），也使得正则表达式更加清晰易读。</p>
	<p>一个显而易见的应用场景是：如果需要完整匹配某个单词时，在Magic模式下需要</p>
有些单词，尤其是短词，常常会出现在其他单词内部，比如，the 就会在 these、they、their 等单词中出现。如果想精确匹配 the 这个完整的单词而不是其他词的组成部分。</p>
<p>在 very magic 搜索模式下，用 <code>&lt;</code> 与 <code>&gt;</code> 符号表示<strong>单词定界符</strong>。</p>
</blockquote>
<p>因此，如果将查找命令改为 <code>/\v&lt;the&gt;</code>，就会精确查找到 the 这个单词。</p>
<p>当然，在 magic、以及 very nomagic 搜索模式下，<code>&lt;</code> 与 <code>&gt;</code> 都必须使用 <code>\</code> 进行转义才能将其作为单词定界符，而如果想在 very magic 搜索模式下匹配尖括号本身的话，也必须将其转义才有单词定界符的含义。如果你还没理解这两句话，建议再细读下上面关于magic、以及 very nomagic 搜索模式的规则介绍。</p>

	<h2 class="article"><a id="regex-very-no-magic-mode"></a>Very No Magic Mode</h2>
<p><code>\V</code> 选项会使得其后的模式中<strong>有且只有反斜杠</strong> <code>\</code> 具有特殊意义，即消除了附加在 <code>.</code>、<code>*</code> 以及 <code>?</code> 等大多数字符上的特殊含义。</p>

	<p>假设需要在以下文本中查找&ldquo;a.k.a&rdquo;，</p>
	<p style="color:#fff; background-color:#1D1F21; width:21em; padding:10px">
	The N key searches backward<br />
	the \v pattern switch (a.k.a. very magic search)</p>
	<p>因为&ldquo;.&rdquo;在正则表达式中具有特殊含义，它会匹配任意字符，所以使用以下命令，将会同时匹配单词&ldquo;backward&rdquo;中的部分字符：</p>
	<p style="text-indent:2em"><code class="inset">/a.k.a</code></p>
	<p style="color:#fff; background-color:#1D1F21; width:21em; padding:10px">
	The N key searches b<span style="background-color:#FDAD00">ackwa</span>rd<br />
	the \v pattern switch (<span style="background-color:#FDAD00">a.k.a</span>. very magic search)</p>
	<p>当然，可以使用转义符来消除的&ldquo;.&rdquo;特殊含义：</p>
	<p style="text-indent:2em"><code class="inset">/a\.k\.a\.</code></p>
	<p>而更简单的方法是，在命令中使用<code>\V</code>激活very nomagic模式：</p>
	<p style="text-indent:2em"><code class="inset">/\Va.k.a.</code></p>
	<p>此时，将只会匹配到单词&ldquo;a.k.a&rdquo;：</p>
	<p style="color:#fff; background-color:#1D1F21; width:21em; padding:10px">
	The N key searches backward<br />
	the \v pattern switch (<span style="background-color:#FDAD00">a.k.a</span>. very magic search)</p>

	<p>Start a search with <code class="highlighter-rouge">\V</code>. Now you <em>only have to escape</em> <code class="highlighter-rouge">/</code> and <code class="highlighter-rouge">\</code>. It would be nice if you didn’t have to escape <em>anything</em>, but alas vim is not like this.</p>
<p>Let’s say you have this file</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>www.yahoo.com
blah some other stuff
www.google.com
www.ebay.org
</code></pre></div></div>
<p>And you want to change it to</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>www.chase.com
blah some other stuff
www.chase.com
www.chase.org
</code></pre></div></div>
<p>What you’re doing is saying <em>find all domain names and change the inner part to <code class="highlighter-rouge">chase</code></em>. You can do this by specifying the part of the search to <em>match</em>.
Put <code class="highlighter-rouge">\zs</code> before where you want to match and <code class="highlighter-rouge">\ze</code> after where you want to match.</p>

<p>So in this case: <code class="highlighter-rouge">\v</code> <code class="highlighter-rouge">www\.</code> <strong>\zs</strong> <code class="highlighter-rouge">.*</code> <strong>\ze</strong> <code class="highlighter-rouge">\.com</code></p>

<ul>
  <li>An extension to this is looking for the start of a word without matching it. For example looking for the variable <code class="highlighter-rouge">i</code>. We could then use this search: <code class="highlighter-rouge">\v\W\zsi\ze\W</code>. Note: Use <code class="highlighter-rouge">\W</code> matches everything except <code class="highlighter-rouge">[a-zA-Z0-9_]</code>
    <ul>
      <li>There’s a shortcut called word boundaries, with <code class="highlighter-rouge">&lt;</code> and <code class="highlighter-rouge">&gt;</code>:
        <ul>
          <li><code class="highlighter-rouge">\v&lt;i&gt;</code> (<a href="http://vim.wikia.com/wiki/Search_patterns">More info</a>)</li>
          <li>You can get this same behavior by pressing <code class="highlighter-rouge">*</code> in normal mode, while having your cursor over the word you want to search.</li>

假设需要在一个CSS样式文件中查找所有的<strong>颜色代码</strong>，部分查找目标如下所示。</p>
<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a { color: #0000EE; }</span><br><span class="line">body { color: #3c3c3c; }</span><br><span class="line">strong { color: #000; }</span><br></pre></td></tr></tbody></table></figure>
<p>为此，需要构造一个正则表达式，用于匹配 1个 # 字符以及紧随其后的 3 个或 6 个十六进制字符的目标串 (包括所有数字以及大写或小写的字母 A 到 F)。</p>
<h4>1. 使用 magic 搜索模式查找</h4><p>Vim默认设置下，<code>/#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)</code> 可以查找到所有的目标颜色代码。</p>
<p>在上面的Vim正则表达式搜索命令中，一共用到了 3 类括号：[]、() 和 {}，而这 3 类括号都是正则表达式中的<strong>特殊字符</strong> (有<strong>特殊含义</strong>的字符)，若要匹配这些特殊字符，必须首先使 <code>\</code> 进行转义。</p>
<p>正则表达式中，方括号 [] 用于定义待匹配的字符范围，原括号 () 用于标记一个子表达式的开始和结束位置，而花括号 {} 用于指定匹配的长度。</p>
<blockquote>
<p>对于Vim的正则表达式引擎来说，方括号 [] 缺省具有特殊含义，不需要转义；圆括号 () 默认会按原义匹配字符，因此需要使用 \ 转义，使其具有特殊含义；花括号 {} 也一样需要使用 \ 转义，但与之对应的闭括号则不用，因为 Vim 会自动推测我们的意图。这就是Vim的 magic 搜索模式。</p>
</blockquote>
<p>magic 搜索模式会<strong>自动</strong>为某些额外的符号赋予特殊含义，例如 <code>.</code> 、<code>*</code>、<code>[</code> 等。magic 模式的初衷是想能在Vim中更容易地构造简单的正则表达式，但它却没能为诸如 <code>+</code>、<code>?</code>、<code>(</code>、<code>)</code>、<code>{</code> 等符号赋予特殊含义，这些符号还必须经过转义才具有特殊含义。</p>
<p>这种”半成品”性质的实现，使得在Vim下构建正则表达式搜索模式，仍然十分麻烦，从上面查找颜色代码的命令就可感受一二。</p>
<h4 id="2-使用-very-magic-搜索模式查找"><a href="#2-使用-very-magic-搜索模式查找" class="headerlink" title="2. 使用 very magic 搜索模式查找"></a>2. 使用 very magic 搜索模式查找</h4><p>如上所述，magic 搜索模式下，字符转义的规则制定得比较混乱，容易混淆。</p>
<p>可以使用 <code>\v</code> 开关激活 very magic 搜索模式，统一所有<strong>特殊符号</strong>的规则：</p>
<blockquote>
<p>very magic 搜索模式下，除下划线 <code>_</code>、大小写字母以及数字 0 到 9 之<strong>外</strong>的所有字符<strong>都具有</strong>特殊含义。</p>
</blockquote>
<p>例如，使用 <code>\v</code> 模式开关查找上述匹配十六进制颜色代码的正则表达式可简化为：<code>/\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})</code>。</p>
<p>由于出现在起始位置的 \v 开关，位于它后面的所有字符都<strong>具有特殊含义</strong>，用于转义的反斜杠字符就可以去掉，正则表达式的可读性更强了。</p>


<p>其实，very magic 和 very nomagic 搜索模式分别是Vim对正则表达式特殊字符的两种极端处理方式。</p>
<p>对于Vim的正则表达式搜索，一个通用的原则是：如果想按正则表达式查找，就用模式开关 <code>\v</code>，如果想按原义查找文本，就用原义开关 <code>\V</code>。</p>

<h4>界定匹配的边界</h4><p>在使用Vim的某些场景下，可能想指定一个范围较广的模式，但只对匹配结果的一部分内容感兴趣。</p>
<p>应该明确，当我们谈论一个<strong>模式</strong>的时候，指的是在查找域输入的正则表达式 (或按原义匹配的文本)；而<strong>匹配</strong>，是指在文档中被高亮显示的文本内容。</p>
<blockquote>
<p>一个<strong>匹配</strong>的边界通常对应一个<strong>模式</strong>的起始与结尾。但可以使用元字符 <code>\zs</code> 与 <code>\ze</code> 对<strong>匹配</strong>进行裁剪，使其成为这个完整<strong>模式</strong>的一个子集。</p>
</blockquote>
<p>元字符 <code>\zs</code> 标志着一个匹配的起始，而元字符 <code>\ze</code> 则用来界定匹配的结束。将二者相结合，可以让我们先定义一个模式来匹配一个较大的文本范围，然后再收窄匹配范围。例如：</p>
<p>如果使用Vim查找命令 <code>/Practical Vim</code>，则文档中所有出现 Practical Vim 的地方都会被搜索出来。一旦将查找模式改为 <code>/Practical \zsVim</code>，则只有单词 Vim 会被高亮选中，而单词 Practical 会被排除于<strong>匹配</strong>之外，但它仍是<strong>模式</strong>的一部分。</p>
<p>如此一来，只有紧跟着单词 Practical 的 Vim 才会被查找到，而其他前面不是 Practical 的 Vim 则不会被匹配。这与通过 <code>/Vim</code> 命令进行简单查找的结果有很大不同。</p>
</div>
	<table summary="Commands" border="2" frame="hsides" rules="all" cellspacing="0" cellpadding="3">
		<caption>命令小结</caption>
		<tr><td><code class="inset">:</code></td><td rowspan="2"></td></tr>
		<tr><td><code class="inset">:</code></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
	</table>
&ldquo;&rdquo;

	<p style="border-top:1px solid lightgray"><span style="float:right">Ver: 2.0&nbsp;|&nbsp;<a href="mailto:yyq123@gmail.com">YYQ</a></span><span>&lt;<a title="" href="http://yyq123.github.io/learn-vim/.html">上一篇</a>&nbsp;|<a title="笔记列表" href="http://yyq123.github.com/learn-vim/learn-vi-00-00-TOC.html">&nbsp;目录&nbsp;</a>|&nbsp;<a title="" href="http://yyq123.github.io/learn-vim/.html">下一篇</a>&gt;</span></p>

</body>
</html>
